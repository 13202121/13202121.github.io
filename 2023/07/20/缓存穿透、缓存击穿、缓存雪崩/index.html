<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>缓存穿透、缓存击穿、缓存雪崩 | 码夫 Code Mover</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">缓存穿透、缓存击穿、缓存雪崩</h1><a id="logo" href="/.">码夫 Code Mover</a><p class="description">我是一个写Bug的代码搬运工</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-4-4"><div class="content_container"><div class="post"><h1 class="post-title">缓存穿透、缓存击穿、缓存雪崩</h1><div class="post-meta">2023-07-20<span> | </span><span class="category"><a href="/categories/后端/">后端</a></span></div><div class="post-content"><h2 id="一、缓存穿透"><a href="#一、缓存穿透" class="headerlink" title="一、缓存穿透"></a>一、缓存穿透</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p><b style="color:#f66;">Key 对应的数据在 Redis 中并不存在</b>，每次针对此 Key 的请求从缓存获取不到，请求将会从数据库中查询，访问量大了可能压垮数据库。比如用一个不存在的用户 ID 获取用户信息，Redis 缓存和数据库中都没有，若黑客利用此漏洞进行攻击可能压垮数据库（<strong>黑客访问肯定不存在的数据，造成服务器压力大</strong>）。</p>
<h3 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h3><p>一个一定不存在的数据，由于缓存是不命中时查询后被动写入，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</p>
<ul>
<li><strong>对空值缓存：</strong> 如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然将这个空结果（null）进行缓存，这样可以缓解数据库的访问压力，然后设置空结果的过期时间一般短一些，最长不超过五分钟。（只能作为简单的应急方案）</li>
<li><strong>设置可访问的名单（白名单）：</strong> 使用 Bitmaps 类型定义一个可以访问的名单，名单 ID 作为 Bitmaps 的偏移量，每次访问进行与 Bitmaps 里面的 ID 进行比较，如果访问 ID 不在 Bitmaps 里面，进行拦截不允许访问。</li>
<li><strong>布隆过滤器：</strong> 将所有可能存在的数据哈希到一个足够大的 Bitmaps 中，一个一定不存在的数据会被这个过滤器拦截掉，从而避免了对底层存储系统的查询压力。</li>
<li><strong>进行实时监控：</strong> 当发现 Redis 的命中率开始急速降低，需要排查访问对象和访问的数据和运维人员配合可以设置黑名单限制服务。</li>
</ul>
<h2 id="二、缓存击穿"><a href="#二、缓存击穿" class="headerlink" title="二、缓存击穿"></a>二、缓存击穿</h2><h3 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1. 概念"></a>1. 概念</h3><p><b style="color:#f66">Key 对应的数据存在,但在 Redis 中过期</b>，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从数据库中查询并回写至缓存，这个时候大量并发的请求可能会瞬间数据库压垮。（<strong>Redis某个 Key 过期，大量的合理数据请求到达数据库</strong>）</p>
<h3 id="2-解决方案-1"><a href="#2-解决方案-1" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h3><ul>
<li><strong>预先设置热门数据：</strong> 在 Redis 高峰访问之前，把一些热门数据提前加载到 Redis 里面，加大这些热门数据 Key 的时长。</li>
<li><strong>实时调整：</strong> 现场监控哪些数据是热门数据，实时调整其对应 Key 的过期时长。</li>
<li><strong>使用互斥锁加递归：</strong><br>（1）即在缓存失效的时候（判断拿出来的值为空），不是立即从数据库查询；<br>（2）先使用互斥锁进行加锁；<br>（3）当加锁成功后，再进行从数据库查询，并回写至缓存中,最后释放锁。<br>（4）当加锁失败，证明有线程在从数据库查询，当前线程睡眠一段时间再重试从缓存中获取数据，若不存在，再递归执行加锁后查询数据。</li>
</ul>
<p>代码示例：</p>
<ul>
<li><p>获得锁的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">	Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">"1"</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">	<span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>释放锁的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">	stringRedisTemplate.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>请求数据方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">queryById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//互斥锁解决缓存击穿</span></span><br><span class="line">	Shop shop = queryWithMutex(id);</span><br><span class="line">	<span class="keyword">if</span> (shop == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> Result.fail(<span class="string">"店铺不存在！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//返回</span></span><br><span class="line">	<span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Shop <span class="title">queryWithMutex</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">	String key = CACHE_SHOP_KEY + id;</span><br><span class="line">	<span class="comment">//1.从redis查询商铺缓存</span></span><br><span class="line">	String shopJson = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">	<span class="comment">//2.判断是否存在</span></span><br><span class="line">	<span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">		<span class="comment">//3.存在，直接返回</span></span><br><span class="line">		Shop shop = JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">		<span class="keyword">return</span> shop;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (shopJson != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//4.实现缓存重建</span></span><br><span class="line">	<span class="comment">//4.1获取互斥锁</span></span><br><span class="line">	String lockKey = <span class="string">"lock:shop:"</span> + id;</span><br><span class="line">	Shop shop = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">boolean</span> isLock = tryLock(lockKey);</span><br><span class="line">		<span class="comment">//4.2判断是否获取成功</span></span><br><span class="line">		<span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">			<span class="comment">//4.3失败，则休眠并重试</span></span><br><span class="line">			Thread.sleep(<span class="number">50</span>);</span><br><span class="line">			<span class="comment">//递归</span></span><br><span class="line">			<span class="keyword">return</span> queryWithMutex(id);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//4.4成功，根据id查询数据库</span></span><br><span class="line">		shop = getById(id);</span><br><span class="line">		<span class="comment">//5.不存在，返回错误</span></span><br><span class="line">		<span class="keyword">if</span> (shop == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//缓存击穿问题</span></span><br><span class="line">			<span class="comment">//将空值写入redis</span></span><br><span class="line">			stringRedisTemplate.opsForValue().set(key, <span class="string">""</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//6.存在，写入redis</span></span><br><span class="line">		stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">//7.释放互斥锁</span></span><br><span class="line">		unlock(lockKey);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//8.返回</span></span><br><span class="line">	<span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="三、缓存雪崩"><a href="#三、缓存雪崩" class="headerlink" title="三、缓存雪崩"></a>三、缓存雪崩</h2><h3 id="1-概念-2"><a href="#1-概念-2" class="headerlink" title="1. 概念"></a>1. 概念</h3><p><b style="color:#f66;">Key 对应的数据存在，但在 Redis 中过期</b>，<em>缓存雪崩针</em> 对是极小时间段内，大量 Key 失效缓存导致，引发数据库压力激增；<em>缓存击穿</em> 则是极小时间段内，某一个热门 Key 缓存导致,引发数据库压力激增。</p>
<h3 id="2-解决方案-2"><a href="#2-解决方案-2" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h3><ul>
<li><p><strong>构建多级缓存架构：</strong> nginx 缓存 + redis 缓存 + 其他缓存（ehcache 等）。</p>
</li>
<li><p><strong>使用锁或队列：</strong> 用加锁或者队列的方式来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。（<strong>效率低，不适用高并发情况</strong>）</p>
</li>
<li><p><strong>设置过期标志更新缓存：</strong> 记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际 Key 的缓存。</p>
</li>
<li><p><strong>将缓存失效时间分散开：</strong> 可以在原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>
</li>
</ul>
</div><div class="tags"><a href="/tags/Redis/">Redis</a></div><div class="post-nav"><a class="next" href="/2023/05/15/利用OpenSSL创建自签Https证书/">利用OpenSSL创建自签Https证书</a></div></div></div></div><div class="pure-u-1 pure-u-md-4-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">码夫 Code Mover.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>